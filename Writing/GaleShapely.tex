\subsection{Gale-Shapely Algorithm}

The intent of this algorithm is to provide stable pairings between job owners and job seekers based on their ranked preferences. The algorithm's initial conception and definition of stability can be found in Gale and Shapely's 1962 publication in the January \textit{The American Mathematical Monthly} \cite{gale_shapely}. Interestingly, this research was funded by the Office of Naval Research. In short, a stable system is one where every job owner and job seeker are paired with the best possible preference for each; in other words no two job seekers or job owners can switch their assignments to both their benefits. Depending on how to construct this algorithm, the result could be focused on giving preference to the job seeker or to the job owner; we choose here to provide optimality for the job seeker. A given situation could be optimal to both, but by nature of needing an initiating agent we give that to the seeker. Also important to note, since a job owner can have multiple positions (e.g. four ensigns allotted for a ship's CO), that job owner can be matched with multiple seekers, but no seeker can have multiple owners.

This is the same algorithm that won the Nobel Prize in 2012 for its application in the National Residency Match Program. In their case, the algorithm is constructed to provide optimality for the applicant rather than the hospital program. They surmised that providing the best position for the seeker improved organizational performance.

\begin{algorithm}[H]
\SetAlgoLined
\KwResult{There are no pairs $(O_i, S_i), (O_j, S_j)$ such that the pairings $(O_i, S_j), (O_j, S_i)$ would be preferred by all parties.} 
 Consider a set of preferences $\{P^{x}_{y,z} \in \mathbb{Z}^+: x \in \{O,S\}, y \in \{1, \dots, n\}, z \in \{1, \dots, m\}\}$. This indicates the positive integer preference ranking of either the job owner or seeker ($O$ or $S$) for the $n$ available jobs and $m$ seekers. Also know that $l_n$ is the number of available positions in each job.\;
 \For{$c \in \{1, \dots, n\}$}{
 For each job, initialize the job owner's hiring slate to be empty \;
 $O_c = \{\null\}$ \;
 } 
 \For{$c \in \{1, \dots, m\}$}{
 For each job seeker initialize their indicator to say \textit{un-slated} \;
 $I_c = 0$ \;
 Also initialize to look at the first preference of each job seeker \;
 $g_c = 1$\;
 } 
 Check if there are more jobs than seekers, or more seekers than jobs \;
 $a = \max \big(0, m - \sum_{c = 1}^n l_c \big)$\;
 Seek jobs until either all seekers are hired or all jobs are spoken for \;
 \While{\big( $\sum_{c = 1}^m I_c \leq a $ \big)}{
 Iterate through all the job seekers \;
 \For{$c \in \{1, \dots, m\}$}{
 Find a job for a seeker $c$ only if they are not slated for a job \;
 \If{$I_c == 0$}{
 Look for the job that is seeker $c$'s $g^{th}$ preference \;
 $j = r$ such that $P^S_{r,c} = g_c$ \;
 If job $j$ has open positions \;
  \uIf{$|O_j| < l_j$}{
   Add the seeker $c$ to the slate of owner of job $j$ \;
   $O_j += S_c$\;
   Indicate that seeker $c$ tentatively has a job \;
   $I_c = 1$\;
   }
   Or if seeker $c$ preferred by job owner $j$ than their least preferred person currently on their slate \;
   \ElseIf{$P^{O}_{j,c} < P^{O}_{j,w} $ such that $P^{O}_{j,w} = \max \{P^{O}_{j,v} | S_v \in O_j\}$}{
   Remove the seeker $w$ (least preferred) from the slate of owner of job $j$ \;
   $O_j -= S_w$\;
   Indicate that seeker $w$ tentatively does not have a job \;
   $I_w = 0$\;
   Add the seeker $c$ to the slate of owner of job $j$ \;
   $O_j += S_c$\;
   Indicate that seeker $c$ tentatively has a job \;
   $I_c = 1$\;
   }
 Indicate that the $g^{th}+1$ preference of seeker $c$ has been considered \; 
 $g_c++$\;
 } 
 }
 }
 \caption{Deferred Acceptance}
\end{algorithm}
