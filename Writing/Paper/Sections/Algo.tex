A basic algorithm, like Gale-Shapley’s set of instructions for stable marriages, is an important first step in talent allocation. We moved onto a linear programming concept, oriented around solvers:  algorithms that are adaptable. These solvers have varying types like linear, convex, and mixed integer. While Gale-Shapley’s algorithm can be solved in $n^2$ time, ours is $np$-complete, indicating polynomial time completion. What we lose in speed, we gain in the ability to alter the formulation  without total overhaul. These qualities make the approach particularly conducive to constraint creation, a vital requirement for stakeholders utilizing our solution.

Ours is a unique subset of MIP, binary optimization, to reflect the nature of either placement in a specific job, or not (i.e. only 1 or 0). 

%The resulting lattice has an incredibly large number of dimensions manifesting every potential job placement for every individual. Subsequently, we apply constraints, the inherent reason we utilize MIP. These constraints cut away pieces of the lattice to reveal a viable search space to run the minimization function. Finding the minimum point within that constrained lattice provides us with a matrix of the optimally matched jobs and sailors. 

The constraints we apply are the same as the college admissions problem \cite{1985_Roth}, where each job can fill up to but not exceed the allocated number of positions and each sailor can only be assigned to one position with the added constraint that the solution is as good or better than deferred acceptance when compared by the post-match metrics in Section \ref{post-match}. We chose this to show how this approach can improve upon deferred acceptance and to guarantee feasibility (since the deferred acceptance output is a feasible solution);s the explicit program is in Appendix \ref{Matching}. We also provide alternated formulations in the appendices that may be of more interest to military leaders. These include co-location \ref{CoLocation}, quality spread \ref{QualitySpread}, and weighting certain command's preferences over others \ref{CommandWeight}.

%The objective of our algorithm is to optimally minimize the overall deviation from ideal preference. Colloquially, it would be maximization of preference, yet our mathematics calls for a minimization due to the smaller number (closer to one) represents getting closer to ideal preference. 

